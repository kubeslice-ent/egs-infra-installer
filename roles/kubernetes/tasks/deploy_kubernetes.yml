---
- name: Check if Kubernetes deployment is enabled
  fail:
    msg: "Kubernetes deployment is disabled in user_input.yml"
  when: not kubernetes_deployment.enabled | default(false)

- name: Initialize summary tracking
  include_tasks: "{{ playbook_dir }}/tasks/summary_tracker.yml"
  when: kubernetes_deployment.enabled | default(false)

- name: Display current working directory
  command: pwd
  register: current_dir
  changed_when: false
  when: kubernetes_deployment.enabled | default(false)

- name: Read user_input.yml
  slurp:
    src: "{{ playbook_dir }}/user_input.yml"
  register: user_input_content
  when: kubernetes_deployment.enabled | default(false)

- name: Parse user_input.yml content
  set_fact:
    user_input: "{{ user_input_content.content | b64decode | from_yaml }}"
  when: kubernetes_deployment.enabled | default(false)

- name: Set Kubespray variables
  set_fact:
    kube_apiserver_ip: "{{ kubernetes_deployment.api_server.host }}"
    loadbalancer_apiserver:
      address: "{{ kubernetes_deployment.api_server.host }}"
      port: "{{ kubernetes_deployment.api_server.port }}"
  when: kubernetes_deployment.enabled | default(false)

- name: Generate inventory content
  template:
    src: "{{ playbook_dir }}/templates/inventory.ini.j2"
    dest: "{{ inventory_dir }}/kubespray/inventory.ini"
  vars:
    control_plane_nodes: "{{ kubernetes_deployment.control_plane_nodes }}"
    worker_nodes: "{{ kubernetes_deployment.worker_nodes | default([]) }}"
    ssh_key_path: "{{ kubernetes_deployment.ssh_key_path | default('~/.ssh/k8s_rsa') }}"
    default_ansible_user: "{{ kubernetes_deployment.default_ansible_user | default('root') }}"
    kube_apiserver_ip: "{{ kubernetes_deployment.api_server.host }}"
  when: kubernetes_deployment.enabled | default(false)

- name: Show generated inventory file contents
  command: cat {{ inventory_dir }}/kubespray/inventory.ini
  register: inventory_contents
  changed_when: false
  when: kubernetes_deployment.enabled | default(false)

- name: Display debug information
  debug:
    msg: |
      Current Directory: {{ current_dir.stdout }}
      Inventory Path: {{ inventory_dir }}/kubespray/inventory.ini
      Kubespray Dir: {{ kubespray_dir }}
      Group Vars Path: {{ inventory_dir }}/kubespray/group_vars/all/all.yml
  when: kubernetes_deployment.enabled | default(false)

- name: Create async directory
  file:
    path: "/tmp/.ansible_async"
    state: directory
    mode: '0755'
  when: kubernetes_deployment.enabled | default(false)

- name: Set Ansible environment variables
  set_fact:
    ansible_async_dir: "/tmp/.ansible_async"
    ansible_local_tmp: "/tmp/.ansible/tmp"
    ansible_remote_tmp: "/tmp/.ansible/tmp"
  when: kubernetes_deployment.enabled | default(false)

- name: Set node IP variables
  set_fact:
    control_plane_ips: "{{ kubernetes_deployment.control_plane_nodes | map(attribute='private_ip') | map('default', ansible_default_ipv4.address) | list }}"
    worker_node_ips: "{{ kubernetes_deployment.worker_nodes | default([]) | map(attribute='private_ip') | map('default', ansible_default_ipv4.address) | list }}"
    first_control_plane_ip: "{{ kubernetes_deployment.control_plane_nodes[0].private_ip | default(hostvars[groups['kube_control_plane'][0]].ansible_default_ipv4.address) }}"
  when: kubernetes_deployment.enabled | default(false)

- name: Set PATH variable
  set_fact:
    system_path: "{{ ansible_env.PATH | default('/usr/local/bin:/usr/bin:/bin') }}"
    venv_path: "{{ playbook_dir }}/venv"
  when: kubernetes_deployment.enabled | default(false)

- name: Check if virtualenv exists
  stat:
    path: "{{ venv_path }}/bin/python"
  register: venv_python
  when: kubernetes_deployment.enabled | default(false)

- name: Create virtualenv if it doesn't exist
  shell: |
    python3 -m venv {{ venv_path }}
    {{ venv_path }}/bin/pip install --upgrade pip
    {{ venv_path }}/bin/pip install -r {{ playbook_dir }}/requirements.txt
  when: 
    - kubernetes_deployment.enabled | default(false)
    - not venv_python.stat.exists | default(false)

- name: Get Python version from virtualenv
  shell: "{{ venv_path }}/bin/python -c 'import sys; print(\"{}.{}\".format(sys.version_info.major, sys.version_info.minor))'"
  register: python_version
  changed_when: false
  when: kubernetes_deployment.enabled | default(false)

- name: Set Python paths
  set_fact:
    venv_python_path: "{{ venv_path }}/lib/python{{ python_version.stdout }}/site-packages"
  when: kubernetes_deployment.enabled | default(false)

- name: Set Kubespray async configuration
  set_fact:
    kubespray_async_timeout: "{{ kubernetes_deployment.async_config.timeout | default(3600) }}"
    kubespray_poll_interval: "{{ kubernetes_deployment.async_config.poll_interval | default(5) }}"
  when: kubernetes_deployment.enabled | default(false)

- name: Run Kubespray cluster deployment
  shell: |
    timeout {{ kubernetes_deployment.async_config.timeout | default(3600) }} bash -c '. {{ venv_path }}/bin/activate && \
    {{ venv_path }}/bin/ansible-playbook -i {{ inventory_dir }}/kubespray/inventory.ini \
    {{ kubespray_dir }}/cluster.yml \
    -e @{{ inventory_dir }}/kubespray/group_vars/all/all.yml \
    -e @{{ inventory_dir }}/kubespray/group_vars/k8s_cluster/addons.yml \
    -e "kube_apiserver_ip={{ kubernetes_deployment.api_server.host }}" \
    -e "loadbalancer_apiserver={address: \"{{ kubernetes_deployment.api_server.host }}\", port: {{ kubernetes_deployment.api_server.port }}}" \
    -e "apiserver_loadbalancer_domain_name={{ kubernetes_deployment.api_server.host }}" \
    -e "supplementary_addresses_in_ssl_keys=[\"{{ kubernetes_deployment.api_server.host }}\"] + {{ control_plane_ips | to_json }} + {{ worker_node_ips | to_json }}" \
    -e "kube_apiserver_bind_address={{ first_control_plane_ip }}" \
    -e "kube_apiserver_advertise_address={{ first_control_plane_ip }}" \
    -e "kubernetes_deployment={{ kubernetes_deployment }}" \
    --become \
    --become-method={{ kubespray_become_method }} \
    --become-user={{ kubespray_become_user }} \
    -e ansible_ssh_private_key_file={{ kubernetes_deployment.ssh_key_path | expanduser | realpath }} \
    -e ansible_user={{ kubernetes_deployment.default_ansible_user | default("root") }} \
    -e ansible_become_pass="" \
    -e "ANSIBLE_TIMEOUT={{ kubespray_async_timeout }}" \
    -e "ANSIBLE_INTERNAL_POLL_INTERVAL={{ kubespray_poll_interval }}" \
    --ssh-extra-args="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null" \
    -vvvv'
  args:
    executable: /bin/bash
  environment:
    ANSIBLE_ASYNC_DIR: "/tmp/.ansible_async"
    ANSIBLE_LOCAL_TEMP: "/tmp/.ansible/tmp"
    ANSIBLE_REMOTE_TEMP: "/tmp/.ansible/tmp"
    ANSIBLE_CONFIG: "{{ playbook_dir }}/ansible.cfg"
    PATH: "{{ system_path }}:{{ venv_path }}/bin"
    VIRTUAL_ENV: "{{ venv_path }}"
    PYTHONPATH: "{{ venv_python_path }}"
    ANSIBLE_TIMEOUT: "{{ kubespray_async_timeout }}"
    ANSIBLE_INTERNAL_POLL_INTERVAL: "{{ kubespray_poll_interval }}"
  register: kubespray_result
  async: "{{ kubernetes_deployment.async_config.timeout | default(3600) }}"
  poll: "{{ kubernetes_deployment.async_config.poll_interval | default(5) }}"
  ignore_errors: true
  when: kubernetes_deployment.enabled | default(false)

- name: Cleanup temporary deployment script
  file:
    path: "{{ lookup('env', 'HOME') }}/run_kubespray.sh"
    state: absent
  when: kubernetes_deployment.enabled | default(false)

- name: Create output directory
  file:
    path: "{{ playbook_dir }}/output"
    state: directory
    mode: '0755'
  when: kubernetes_deployment.enabled | default(false)
  delegate_to: localhost

- name: Check if control node is same as master node
  stat:
    path: "/etc/kubernetes/admin.conf"
  register: local_kubeconfig
  delegate_to: localhost
  when: kubernetes_deployment.enabled | default(false)

- name: Copy kubeconfig locally if control node is master
  copy:
    src: "/etc/kubernetes/admin.conf"
    dest: "{{ playbook_dir }}/output/kubeconfig"
    mode: '0600'
    remote_src: yes
  become: true
  when: 
    - kubernetes_deployment.enabled | default(false)
    - local_kubeconfig.stat.exists | default(false)
  delegate_to: localhost

- name: Fetch kubeconfig from remote if control node is different
  fetch:
    src: "/etc/kubernetes/admin.conf"
    dest: "{{ playbook_dir }}/output/kubeconfig"
    flat: yes
    mode: '0600'
  become: true
  when: 
    - kubernetes_deployment.enabled | default(false)
    - not local_kubeconfig.stat.exists | default(true)

- name: Wait for Kubernetes API to be available
  shell: |
    . {{ venv_path }}/bin/activate && \
    KUBECONFIG={{ playbook_dir }}/output/kubeconfig kubectl cluster-info
  args:
    executable: /bin/bash
  register: cluster_info_result
  until: cluster_info_result.rc is defined and cluster_info_result.rc == 0
  retries: "{{ ((kubernetes_deployment.async_config.timeout | default(3600)) / 10) | int }}"
  delay: 10
  environment:
    PATH: "{{ system_path }}:{{ venv_path }}/bin"
    VIRTUAL_ENV: "{{ venv_path }}"
    PYTHONPATH: "{{ venv_python_path }}"
  when: kubernetes_deployment.enabled | default(false)
  delegate_to: localhost
  async: "{{ kubernetes_deployment.async_config.timeout | default(3600) }}"
  poll: "{{ kubernetes_deployment.async_config.poll_interval | default(5) }}"

- name: Debug variables
  debug:
    msg:
      - "Playbook dir: {{ playbook_dir }}"
      - "Inventory dir: {{ inventory_dir }}"
      - "Kubespray dir: {{ kubespray_dir }}"
  when: kubernetes_deployment.enabled | default(false) 
